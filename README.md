# Fleet Management System

## Описание

Система управления автопарком предназначена для отслеживания, анализа и оптимизации работы транспортных средств. Она предоставляет возможность управления различными типами транспортных средств, мониторинга их технического состояния и планирования маршрутов.

## Функциональные возможности

- **Учёт различных типов транспортных средств:** Поддержка автомобилей, грузовиков и мотоциклов с уникальными характеристиками.
- **Мониторинг технического состояния:** Управление графиками технического обслуживания и отслеживание состояния транспортных средств.
- **Планирование маршрутов:** Оптимизация маршрутов с учётом трафика с использованием стороннего API. Выгрузка в json-файл c дальнейшей возможной визуализацией
- **Анализ данных:** Оценка эффективности использования транспортных средств.
- **Интеграция с GPS:** Отслеживание местоположения в реальном времени с помощью интеграции с GPS.

## Структура проекта

### Классы

1. **Location**
   - Хранит GPS-координаты.
   - Метод для загрузки координат из файла.

2. **Vehicle**
   - Базовый класс для всех типов транспортных средств.
   - Методы для описания и анализа эффективности использования топлива.

3. **Car, Truck, Motorcycle**
   - Подклассы класса `Vehicle`, представляющие разные типы транспортных средств.

4. **MaintenanceManager**
   - Управляет техническим обслуживанием транспортных средств и отслеживает графики.

5. **FleetManager**
   - Основной класс для управления автопарком, маршрутизацией и местоположениями транспортных средств.

## Использование

### Установка

1. Клонируйте репозиторий:
   ```
   git clone https://github.com/yourusername/fleet-management-system.git
   cd fleet-management-system
   ```

2. Убедитесь, что у вас установлен компилятор C++ (например, g++ или clang++).
3. Скомпилируйте проект:
   ```
   g++ -o fleet_manager main.cpp
   ```

### Запуск

Запустите программу:
```
./fleet_manager
```

## Пример использования

1. Добавление транспортных средств:
   - Создайте объекты `Car`, `Truck` и `Motorcycle`.
   - Добавьте их в `FleetManager`.

2. Построение маршрута:
   - Используйте метод `buildRoute()` в `FleetManager`, чтобы построить маршрут между двумя точками.
     ### Структура JSON маршрута (пример из OSRM API)

Вот пример предполагаемого содержимого файла `route.json`, который был сохранён из OSRM API:

```json
{
    "routes": [
        {
            "geometry": "abcd1234...", 
            "distance": 712345.6, 
            "duration": 34653.4,
            "legs": [
                {
                    "steps": [
                        {
                            "intersections": [{"location": [37.6173, 55.7558]}],
                            "geometry": "ab34..."
                        },
                        {
                            "intersections": [{"location": [30.3351, 59.9343]}],
                            "geometry": "cd56..."
                        }
                    ]
                }
            ]
        }
    ],
    "waypoints": [
        {"name": "Moscow", "location": [37.6173, 55.7558]},
        {"name": "Saint Petersburg", "location": [30.3351, 59.9343]}
    ]
}
```

---

### Основные ключи JSON:
1. `routes[]`:
   - Это основной массив маршрутов. Если запрос предполагает альтернативные маршруты, здесь их может быть несколько (обычно нужен первый).
   - Поля:
     - `geometry`: Линии маршрута, закодированные в формате Polyline, которые можно использовать для визуализации.
     - `distance`: Длина маршрута в метрах.
     - `duration`: Длительность маршрута в секундах.
     - `legs[]`: Содержит пошаговые маршруты с разбивкой по "этапам".

2. `waypoints[]`:
   - Содержит начальную и конечную точки (или любые промежуточные точки).
   - Поля:
     - `name`: Название опорной точки.
     - `location`: Координаты опорной точки (долгота, широта).

3. `legs[]` и `steps[]`:
   - Разбивка пути на участки.
   - Содержит данные для пошаговых инструкций, включая координаты пересечений (`intersections`) и геометрию (`geometry`) отдельных участков.

    

3. Показ статуса технического обслуживания:
   - Используйте метод `maintenanceCheck()` для просмотра статуса технического обслуживания.
## Варианты интерпретации
С помощью сайта https://developers.google.com/maps/documentation/utilities/polylineutility?hl=ru декодируем линию


## Зависимости

- C++11 или более поздняя версия
- Сторонние библиотеки (например, для работы с HTTP API при построении маршрутов)

## Возможности для улучшения

- Расширение функциональности анализа данных.
- Создание пользовательского интерфейса для улучшения взаимодействия пользователя с системой.
- Внедрение поддержки работы с базами данных для хранения информации о транспортных средствах.

